<!DOCTYPE html>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<style>
    * {
        font-family: sans-serif;
        font-size: 14px;
    }

    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        z-index: 1;
    }

    h1 {
        font-family: "Montserrat", sans-serif;
        font-size: 32px;
        margin: 1%;
        %text-shadow: 3px 3px #000000;
    }
    
    h2 {
        font-family: "Montserrat", sans-serif;
        font-size: 24px;
        margin: 1%;
        %text-shadow: 3px 3px #000000;
    }

    #score-container {
        position: absolute;
        width: 200px;
        background: none;
        color: #FFFFFF;
        border: #FFFFFF;
        margin: 10px;
        padding: 10px;
        z-index: 2;
        pointer-events: none;
    }

    #score {
        position: absolute;
        width: 200px;
        background: none;
        color: #FFFFFF;
        border: #FFFFFF;
        margin: 0px;
        padding: 0px;
        z-index: 2;
    }

    #start-screen-header {
        position: absolute;
        margin: 25% 50%;
        width: 400px;
        background: #002771;
        color: #EEEEEE;
        border: none;
        transform: translate(-50%,-150%);
        padding: 0;
        z-index: 3;
    }

    #start-screen-main {
        position: absolute;
        margin: 0% 0%;
        width: 90%;
        background: #060050;
        border: none;
        color: #EEEEEE;
        padding: 2% 5%;
        z-index: 3;
    }

    .gameMenuButton {
        background-color: #003fb6;
        text-shadow: 3px 3px #000000;
        box-shadow: 5px 5px #000000;
        color: #FFFFFF;
        border: none;
        display: inline-block;
        padding: 6px 24px;
        z-index: 2;
        text-decoration: none;
        cursor: pointer;
    }

    .gameMenuButton:hover {
        background-color: #0045c7;
    }

        .gameMenuButton:active {
            position: relative;
            top: 2px;
            left: 2px;
            box-shadow: 3px 3px #000000;
        }
</style>


<head>
    <meta charset="utf-8" />
    <title>Asteroids RTS</title>
</head>

<body oncontextmenu="return false">

    <!--
    <div id="start-screen-header">
    <center>
        <h1>AsterCraft</h1>
        </center>
    <div id="start-screen-main">
        <center>
            <a href="#" onclick="start_game()" class="gameMenuButton"><h1>New Game</h1></a> <br />
            <a href="#" onclick="start_game()" class="gameMenuButton"><h1>Settings</h1></a>
        </center>
    </div>
    </div>
        -->

    <div id="score-container">
        <div id="score"><h1>0</h1></div>
    </div>

    <canvas id="cvs"></canvas>

    <script type="text/javascript">

        document.onmousedown = disable_click;

        function disable_click(event) {
            if (event.button == 2) {
                return false;
            }
        }

        var game_width = window.innerWidth;
        var game_height = window.innerHeight;
        var game_score = 0;
        
        var canvas = document.getElementById("cvs");
        canvas.width = game_width;
        canvas.height = game_height;

        canvas.oncontextmenu = function () { return false;}

        var graphics = canvas.getContext("2d");

        var render_frame_rate = 1000.0 / 60.0;

        var last_frame = (new Date().getTime());

        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, render_frame_rate);
                };
        })();

        function game_loop() {
            requestAnimFrame(game_loop);

            dt = (new Date()).getTime() - last_frame;
            last_frame = (new Date()).getTime();

            draw_game();
            update_game(dt);

            handle_input();
        };

        /* IO CODE */
        var mouse = {
            x: 0.0,
            y: 0.0,
            down_x: 0.0,
            down_y: 0.0,
            is_down: -1,
            is_clicked: -1,
            is_dragging: false,
            down_time: -1,
            click_time_left: 135,
            click_time_right: 200,
            mode: "select",
            is_locked: false
        };

        mouse.selected_image = new Image();
        mouse.selected_image.src = "graphics/mouse_select.svg";

        mouse.attack_image = new Image();
        mouse.attack_image.src = "graphics/mouse_attack.svg";

        canvas.addEventListener(
            "mousemove",
            function (input) {
                if (mouse.is_locked) {
                    mouse.x += input.movementX;
                    mouse.y += input.movementY;

                    if (mouse.x > game_width)
                        mouse.x -= game_width;
                    if (mouse.x < 0)
                        mouse.x += game_width;

                    if (mouse.y > game_height)
                        mouse.y -= game_height;
                    if (mouse.y < 0)
                        mouse.y += game_height;

                    if (mouse.is_down != -1 && !mouse.is_dragging) {
                        var dist_sq = (mouse.x - mouse.down_x) * (mouse.x - mouse.down_x) + (mouse.y - mouse.down_y) * (mouse.y - mouse.down_y);
                        var min_click_dist_sq = 40 * 40;

                        if (dist_sq > min_click_dist_sq)
                            mouse.is_dragging = true;
                    }
                } else {
                    mouse.x = input.x;
                    mouse.y = input.y;
                }
            }, false);

        canvas.addEventListener(
            "mousedown",
            function (input) {
                mouse.is_down = input.button;
                mouse.down_time = (new Date()).getTime();
                mouse.down_x = mouse.x;
                mouse.down_y = mouse.y;
                mouse.is_dragging = false;
            }, false);

        canvas.addEventListener(
            "mouseup",
            function (input) {
                var dist_sq = (mouse.x - mouse.down_x) * (mouse.x - mouse.down_x) + (mouse.y - mouse.down_y) * (mouse.y - mouse.down_y);
                var min_click_distance = 40 * 40;

                if (mouse.is_down == 0 && !mouse.is_dragging)
                    mouse.is_clicked = mouse.is_down;

                if (mouse.is_down == 2)
                    mouse.is_clicked = mouse.is_down;

                mouse.is_down = -1;
                mouse.down_time = -1;
            }, false);

        canvas.onclick = function () {
            if (!mouse.is_locked) {
                canvas.request_pointer_lock =
                    canvas.requestPointerLock ||
                    canvas.mozRequestPointerLock ||
                    canvas.webkitRequestPointerLock;
                canvas.request_pointer_lock();
            }
        }
        
        document.addEventListener("pointerlockchange", pointer_lock_change, false);
        document.addEventListener("mozpointerlockchange", pointer_lock_change, false);
        document.addEventListener("webkitpointerlockchange", pointer_lock_change, false);

        function pointer_lock_change(e) {
            if (document.pointerLockElement == canvas ||
                document.mosPointerLockElement == canvas ||
                document.webkitPointerLockElement == canvas) {

                canvas.onclick = null;
                mouse.is_locked = true;
            } else {
                canvas.onclick = function () {
                    if (!mouse.is_locked) {
                        canvas.request_pointer_lock =
                            canvas.requestPointerLock ||
                            canvas.mozRequestPointerLock ||
                            canvas.webkitRequestPointerLock;
                        canvas.request_pointer_lock();
                    }
                }

                mouse.is_locked = false;
            }
        }

        function draw_mouse() {
            graphics.save();

            graphics.translate(mouse.x, mouse.y);

            if (mouse.mode == "select")
                graphics.drawImage(mouse.selected_image, 0, 0);
            else if (mouse.mode == "attack")
                graphics.drawImage(mouse.attack_image, -mouse.attack_image.width / 2.0, -mouse.attack_image.height / 2.0);

            graphics.restore();
        }

        keyboard = {ATTACK_KEY: 65};

        document.body.addEventListener(
            "keydown",
            function (input) {
                keyboard[input.keyCode] = true;

                if (input.keyCode == keyboard.ATTACK_KEY && selected_ships.length > 0)
                    mouse.mode = "attack";

            }, false);

        document.body.addEventListener(
            "keyup",
            function (input) {
                delete keyboard[input.keyCode];
            }, false);

        /* SHIP CODE */
        var ship_graphic = new Image();
        var ship_graphic_loaded = false;
        ship_graphic.src = "graphics/ship.svg";
        ship_graphic.radius = -1;
        ship_graphic.addEventListener(
            "load",
            function () {
                ship_graphic_loaded = true;
                ship_graphic.radius = Math.sqrt(
                    ship_graphic.width * ship_graphic.width + ship_graphic.height * ship_graphic.height) / 2.0;
            }
        );

        var selected_ships = [];
        var ships = [];

        function draw_ship(ship, offset) {
            var color = "#1ef9de";
            var size = 20.0;

            graphics.save();

            graphics.translate(ship.x + offset.x, ship.y + offset.y);
            graphics.rotate(ship.angle);

            if (ship_graphic_loaded) 
                graphics.drawImage(ship_graphic, -ship_graphic.width/2.0, -ship_graphic.height/2.0);

            graphics.restore();
        }

        function draw_ship_selector(ship, ship_selector) {
            var color = "#FFFFFF";
            var size = 10.0;

            graphics.save();

            graphics.translate(ship.x, ship.y);

            graphics.strokeStyle = color;
            graphics.lineWidth = 2;

            graphics.beginPath();

            graphics.moveTo(-ship_graphic.width / 2.0, -ship_graphic.height / 2.0 + size);
            graphics.lineTo(-ship_graphic.width / 2.0, -ship_graphic.height / 2.0);
            graphics.lineTo(-ship_graphic.width / 2.0 + size, -ship_graphic.height / 2.0);

            graphics.moveTo(ship_graphic.width / 2.0, -ship_graphic.height / 2.0 + size);
            graphics.lineTo(ship_graphic.width / 2.0, -ship_graphic.height / 2.0);
            graphics.lineTo(ship_graphic.width / 2.0 - size, -ship_graphic.height / 2.0);

            graphics.moveTo(ship_graphic.width / 2.0, ship_graphic.height / 2.0 - size);
            graphics.lineTo(ship_graphic.width / 2.0, ship_graphic.height / 2.0);
            graphics.lineTo(ship_graphic.width / 2.0 - size, ship_graphic.height / 2.0);

            graphics.moveTo(-ship_graphic.width / 2.0, ship_graphic.height / 2.0 - size);
            graphics.lineTo(-ship_graphic.width / 2.0, ship_graphic.height / 2.0);
            graphics.lineTo(-ship_graphic.width / 2.0 + size, ship_graphic.height / 2.0);

            graphics.stroke();

            graphics.restore();
        }


        function move(ship) {
            var dx = ship.target.x - ship.x;
            var dy = ship.target.y - ship.y;

            if (Math.abs(dx) > game_width / 2.0)
                dx -= Math.sign(dx) * game_width;
            if (Math.abs(dy) > game_height / 2.0)
                dy -= Math.sign(dy) * game_height;

            var norm = Math.sqrt(dx * dx + dy * dy);

            if (norm < game_parameters.ship_speed * dt)
                norm = game_parameters.ship_speed * dt;

            if (norm < game_parameters.min_ship_to_target) {
                ship.target.active = false;
            } else {
                ship.x += dx / norm * game_parameters.ship_speed * dt;
                ship.y += dy / norm * game_parameters.ship_speed * dt;

                if (ship.x > game_width)
                    ship.x -= game_width;
                if (ship.x < 0)
                    ship.x += game_width;
                if (ship.y > game_height)
                    ship.y -= game_height;
                if (ship.y < 0)
                    ship.y += game_height;

                ship.angle = Math.atan2(dy, dx) + Math.PI / 2.0;
            }

            return ship
        }

        function attack(ship, target) {
            var dx = target.x - ship.x;
            var dy = target.y - ship.y;

            if (Math.abs(dx) > game_width / 2.0)
                dx -= Math.sign(dx) * game_width;
            if (Math.abs(dy) > game_height / 2.0)
                dy -= Math.sign(dy) * game_height;

            var norm = Math.sqrt(dx * dx + dy * dy);

            if (norm > game_parameters.ship_attack_range) {
                ship.x += dx / norm * game_parameters.ship_speed * dt;
                ship.y += dy / norm * game_parameters.ship_speed * dt;

                if (ship.x > game_width)
                    ship.x -= game_width;
                if (ship.x < 0)
                    ship.x += game_width;
                if (ship.y > game_height)
                    ship.y -= game_height;
                if (ship.y < 0)
                    ship.y += game_height;

                ship.angle = Math.atan2(dy, dx) + Math.PI / 2.0;
            } else {
                ship.angle = Math.atan2(dy, dx) + Math.PI / 2.0;

                if ((new Date()).getTime() - ship.last_fired > game_parameters.ship_fire_rate) {
                    bullets.push({
                        x: ship.x + ship_graphic.radius * dx / norm,
                        y: ship.y + ship_graphic.radius * dy / norm,
                        vx: dx / norm * game_parameters.bullet_speed,
                        vy: dy / norm * game_parameters.bullet_speed,
                        fire_time: (new Date()).getTime()
                    });

                    ship.last_fired = (new Date()).getTime();
                }
            }

            return ship
        }

        /* ASTEROID CODE */
        function draw_asteroid(asteroid, offset) {
            var color = "#AAAAAA";

            graphics.lineWidth = 4;
            graphics.strokeStyle = color;

            graphics.save();
            graphics.translate(asteroid.x + offset.x, asteroid.y + offset.y);
            graphics.rotate(asteroid.angle);

            graphics.beginPath();
            graphics.moveTo(asteroid.vertices[0].x, asteroid.vertices[0].y);

            for (var i = 0; i < asteroid.vertices.length; i++) {
                graphics.lineTo(asteroid.vertices[i].x, asteroid.vertices[i].y);
            }

            graphics.lineTo(asteroid.vertices[0].x, asteroid.vertices[0].y);

            graphics.stroke();
            graphics.restore();

        }

        function draw_periodic(drawable, draw_func) {
            draw_func(drawable, { x: 0.0, y: 0.0 });

            var buffer = drawable.max_radius;

            for (var dx = -1; dx <= 1; dx++) {
                for (var dy = -1; dy <= 1; dy++) {
                    if (dx == 0 && dy == 0)
                        continue;

                    var offset = { x: 0.0, y: 0.0 };

                    if (dx == -1 && drawable.x < buffer)
                        offset.x += game_width;

                    if (dx == 1 && drawable.x > game_width - buffer)
                        offset.x -= game_width;

                    if (dy == -1 && drawable.y < buffer)
                        offset.y += game_height;

                    if (dy == 1 && drawable.y > game_height - buffer)
                        offset.y -= game_height;

                    draw_func(drawable, offset);
                }
            }

        }

        function point_in_asteroid_image(x, y, asteroid, offset) {
            var intersections = 0;

            var c_theta = Math.cos(asteroid.angle);
            var s_theta = Math.sin(asteroid.angle);

            asteroid.x += offset.x;
            asteroid.y += offset.y;

            if (Math.abs(x - asteroid.x) > game_width / 2.0)
                x -= Math.sign(x - asteroid.x);
            if (Math.abs(y - asteroid.y) > game_height / 2.0)
                y -= Math.sign(y - asteroid.y);

            var v_old = {
                x: asteroid.x + c_theta * asteroid.vertices[0].x - s_theta * asteroid.vertices[0].y,
                y: asteroid.y + s_theta * asteroid.vertices[0].x + c_theta * asteroid.vertices[0].y
            }

            for (var i = 1; i <= asteroid.vertices.length; i++) {
                var index = i % asteroid.vertices.length;

                var v = {
                    x: asteroid.x + c_theta * asteroid.vertices[index].x - s_theta * asteroid.vertices[index].y,
                    y: asteroid.y + s_theta * asteroid.vertices[index].x + c_theta * asteroid.vertices[index].y
                }

                var t_2 = (y - v_old.y) / (v.y - v_old.y);
                var t_1 = -(x - v_old.x) + t_2 * (v.x - v_old.x);

                v_old = v;

                if (t_2 < 0 || t_2 > 1)
                    continue;

                if (t_1 >= 0)
                    intersections++;
            }

            return intersections % 2 == 1;
        }

        function point_in_asteroid(x, y, asteroid) {

            if (point_in_asteroid_image(x, y, asteroid, { x: 0.0, y: 0.0 }))
                return true;

            var buffer = asteroid.max_radius;

            for (var dx = -1; dx <= 1; dx++) {
                for (var dy = -1; dy <= 1; dy++) {
                    if (dx == 0 && dy == 0)
                        continue;

                    var offset = { x: 0.0, y: 0.0 };

                    if (dx == -1 && asteroid.x < buffer)
                        offset.x += game_width;

                    if (dx == 1 && asteroid.x > game_width - buffer)
                        offset.x -= game_width;

                    if (dy == -1 && asteroid.y < buffer)
                        offset.y += game_height;

                    if (dy == 1 && asteroid.y > game_height - buffer)
                        offset.y -= game_height;

                    if (point_in_asteroid_image(x, y, asteroid, offset))
                        return true;
                }
            }

            return false;
        }

        // NOTE(schsam): For now we will do asteroid-disk collision, but this
        // might not be great. If so, we can implement different kinds of
        // collision for different kinds of objects separately.
        function ship_asteroid_intersection_image(ship, asteroid, offset) {
            var c_theta = Math.cos(asteroid.angle);
            var s_theta = Math.sin(asteroid.angle);

            asteroid.x += offset.x;
            asteroid.y += offset.y;

            var v_old = {
                x: asteroid.x + c_theta * asteroid.vertices[0].x - s_theta * asteroid.vertices[0].y,
                y: asteroid.y + s_theta * asteroid.vertices[0].x + c_theta * asteroid.vertices[0].y
            }

            var r_sqr = ship_graphic.radius * ship_graphic.radius;

            for (var i = 1; i <= asteroid.vertices.length; i++) {
                var index = i % asteroid.vertices.length;

                var v = {
                    x: asteroid.x + c_theta * asteroid.vertices[index].x - s_theta * asteroid.vertices[index].y,
                    y: asteroid.y + s_theta * asteroid.vertices[index].x + c_theta * asteroid.vertices[index].y
                }

                //l = l_0 + t(l_1 - l_0).
                //(l - r)^2 = R^2
                //(l_0 - r)^2 + 2t(l_1 - l_0).(l_0 - r) + t^2(l_1 - l_0)^2 - R^2 = 0
                var a = (v.x - v_old.x) * (v.x - v_old.x) + (v.y - v_old.y) * (v.y - v_old.y);
                var b = 2 * ((v.x - v_old.x) * (v_old.x - ship.x) + (v.y - v_old.y) * (v_old.y - ship.y));
                var c = (ship.x - v_old.x) * (ship.x - v_old.x) + (ship.y - v_old.y) * (ship.y - v_old.y) - r_sqr;

                var disc = (b * b - 4 * a * c);

                if (disc <= 0)
                    continue;

                var t_1 = (-b + Math.sqrt(disc)) / (2 * a);
                var t_2 = (-b - Math.sqrt(disc)) / (2 * a);

                v_old = v;

                if ((t_1 < 0 || t_1 > 1) && (t_2 < 0 || t_2 > 1))
                    continue;

                return true;
            }

            return false;
        }

        function ship_asteroid_intersection(ship, asteroid) {

            if (ship_asteroid_intersection_image(ship, asteroid, { x: 0.0, y: 0.0 }))
                return true;

            var buffer = asteroid.max_radius;

            for (var dx = -1; dx <= 1; dx++) {
                for (var dy = -1; dy <= 1; dy++) {
                    if (dx == 0 && dy == 0)
                        continue;

                    var offset = { x: 0.0, y: 0.0 };

                    if (dx == -1 && asteroid.x < buffer)
                        offset.x += game_width;

                    if (dx == 1 && asteroid.x > game_width - buffer)
                        offset.x -= game_width;

                    if (dy == -1 && asteroid.y < buffer)
                        offset.y += game_height;

                    if (dy == 1 && asteroid.y > game_height - buffer)
                        offset.y -= game_height;

                    if (ship_asteroid_intersection_image(ship, asteroid, offset))
                        return true;
                }
            }

            return false;
        }

        function create_asteroid(position, size) {
            var vertices = [];
            var angle = 0.0;
            var d_angle_scale = 0.5;
            var d_radius_scale = 0.5;
            var max_radius = 0.0;

            while (angle < 2 * Math.PI) {
                angle += 0.2 + d_angle_scale * Math.random();

                if (angle > 2 * Math.PI)
                    break;

                var radius = size + d_radius_scale * size * (Math.random() - 0.5);

                if (radius > max_radius)
                    max_radius = radius;

                vertices.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            asteroids.push(
                {
                    x: position.x, y: position.y,
                    angle: 0.0,
                    vx: game_parameters.asteroid_velocity_scale * (Math.random() - 0.5),
                    vy: game_parameters.asteroid_velocity_scale * (Math.random() - 0.5),
                    omega: game_parameters.asteroid_omega_scale * (Math.random() - 0.5),
                    vertices: vertices,
                    size: size,
                    health: size,
                    max_radius: max_radius
                });
        }

        var asteroids = [];

        // BULLETS
        var bullet_graphic = new Image();
        var bullet_graphic_loaded = false;
        bullet_graphic.src = "graphics/bullet.svg";
        bullet_graphic.radius = -1;
        bullet_graphic.addEventListener(
            "load",
            function () {
                bullet_graphic_loaded = true;
                bullet_graphic.radius = Math.sqrt(bullet_graphic.width * bullet_graphic.width + bullet_graphic.height * bullet_graphic.height) / 2.0;
            }
        );

        function draw_bullet(bullet) {
            var color = "#1ef9de";
            var size = 20.0;

            graphics.save();

            graphics.translate(bullet.x, bullet.y);

            if (bullet_graphic_loaded)
                graphics.drawImage(bullet_graphic, -bullet_graphic.width / 2.0, -bullet_graphic.height / 2.0);

            graphics.restore();

        }
        
        var bullets = [];

        // CLICK MARKERS
        var click_markers = [];

        function create_click_marker(x, y, color) {
            var initial_size = 0.0;
            var final_size = 30.0;

            var final_color = { r: 46, b: 46, g: 46 };
            var duration = 200;

            click_markers.push(
                {
                    x: x,
                    y: y,
                    initial_size: initial_size,
                    final_size: final_size,
                    initial_color: color,
                    final_color: final_color,
                    creation_time: (new Date()).getTime(),
                    duration: duration
                });
        }

        function lerp(x, y, t) {
            return x + t * (y - x);
        }

        function draw_click_marker(marker, offset) {
            var color = "#1ef9de";

            var t = ((new Date()).getTime() - marker.creation_time) / marker.duration;

            var color = {
                r: lerp(marker.initial_color.r, marker.final_color.r, t),
                g: lerp(marker.initial_color.g, marker.final_color.g, t),
                b: lerp(marker.initial_color.b, marker.final_color.b, t),
            };

            var size = lerp(marker.initial_size, marker.final_size, t);

            graphics.save();

            graphics.translate(marker.x + offset.x, marker.y + offset.y);

            graphics.lineWidth = 3;
            graphics.strokeStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";

            graphics.beginPath();

            graphics.arc(0, 0, size, 0, 2 * Math.PI);

            graphics.stroke();
            graphics.restore();

        }

        /* INITIALIZATION CODE */
        function initialize_game_data() {
            if (!ship_graphic_loaded) {
                requestAnimFrame(initialize_game_data);
                return;
            }

            game_score = 0;

            ships = [];
            asteroids = [];
            selected_ships = [];
            bullets = [];

            for (var i = 0; i < 5; i++) {
                ships.push(
                    {
                        x: game_width / 2.0 + 200 * Math.random() - 100.0,
                        y: game_height / 2.0 + 200 * Math.random() - 100.0,
                        angle: 0.0,
                        target: { x: 0, y: 0, active: false, command_id: 0 },
                        last_fired: (new Date()).getTime(),
                        max_radius: ship_graphic.radius
                    });
            }

            for (var i = 0; i < 1; i++) {

                var position = {
                    x: game_width * Math.random(),
                    y: game_height * Math.random()
                };

                var base_radius = 100 + Math.random() * 60;

                create_asteroid(position, base_radius);
            }

            game_loop();
        }

        /* RENDER / UPDATE CODE */
        function draw_game() {
            graphics.setTransform(1, 0, 0, 1, 0, 0);

            graphics.fillStyle = game_parameters.background_color;

            graphics.fillRect(0, 0, game_width, game_height);

            for (var i = 0; i < ships.length; i++) {
                draw_periodic(ships[i], draw_ship);
            }

            for (var i = 0; i < selected_ships.length; i++) {
                var id = selected_ships[i].id;

                draw_ship_selector(ships[id], selected_ships[i]);
            }

            for (var i = 0; i < asteroids.length; i++) {
                draw_periodic(asteroids[i], draw_asteroid);
            }

            for (var i = 0; i < bullets.length; i++) {
                draw_bullet(bullets[i]);
            }
            
            for (var i = 0; i < click_markers.length; i++) {
                draw_periodic(click_markers[i], draw_click_marker);

                if ((new Date()).getTime() - click_markers[i].creation_time > click_markers[i].duration) {
                    click_markers.splice(i, 1);
                }
            }

            if(mouse.is_locked)
                draw_mouse();
        }

        var game_parameters = {
            background_color: "#2e2e2e",
            ship_fire_rate: 200,
            ship_speed: 0.3,
            min_ship_to_target: 5.0,
            ship_attack_range: 400,
            bullet_speed: 0.5,
            asteroid_velocity_scale: 0.2,
            asteroid_omega_scale: 0.005 
        };

        function update_game(dt) {
            // SHIP TO TARGET LOGIC
            for (var i = 0; i < ships.length; i++) {
                if (ships[i].target.active && ships[i].target.mode == "move")
                    ships[i] = move(ships[i]);

                if (ships[i].target.active && ships[i].target.mode == "attack") {
                    var target = asteroids[ships[i].target.asteroid];

                    ships[i] = attack(ships[i], target);
                }

                if (ships[i].target.active && ships[i].target.mode == "attack-move") {

                    target = null;

                    for (var j = 0; j < asteroids.length; j++) {
                        var norm = Math.sqrt(
                            (ships[i].x - asteroids[j].x) * (ships[i].x - asteroids[j].x) +
                            (ships[i].y - asteroids[j].y) * (ships[i].y - asteroids[j].y));

                        if (norm < game_parameters.ship_attack_range) {
                            target = asteroids[j];
                        }
                    }

                    if (target) {
                        ships[i] = attack(ships[i], target);
                    } else {
                        ships[i] = move(ships[i]);
                    }

                }

            }
        
            // SHIP SHIP OVERLAP
            var ship_repulsion_scale = 1.0;
            var goal_separation_radius = ship_graphic.radius * 3;

            for (var i = 0; i < ships.length; i++) {
                for (var j = i + 1; j < ships.length; j++) {
                    var dx = ships[i].x - ships[j].x;
                    var dy = ships[i].y - ships[j].y;

                    var norm = Math.sqrt(dx * dx + dy * dy);

                    if (norm < goal_separation_radius) {
                        ships[i].x += (1.0 - norm / goal_separation_radius) * dx / norm * dt * ship_repulsion_scale;
                        ships[i].y += (1.0 - norm / goal_separation_radius) * dx / norm * dt * ship_repulsion_scale;
                        ships[j].x -= (1.0 - norm / goal_separation_radius) * dx / norm * dt * ship_repulsion_scale;
                        ships[j].y -= (1.0 - norm / goal_separation_radius) * dy / norm * dt * ship_repulsion_scale;

                        if ((ships[i].target.mode == "move" || ships[i].target.mode == "attack-move") &&
                            ships[i].target.command_id == ships[j].target.command_id) {
                            ships[i].target.active = ships[i].target.active && ships[j].target.active;
                            ships[j].target.active = ships[i].target.active && ships[j].target.active;
                        }
                    }
                }
            }

            // SHIP ASTEROID OVERLAP
            for (var i = 0; i < ships.length; i++) {
                for (var j = 0; j < asteroids.length; j++) {
                    if (ship_asteroid_intersection(ships[i], asteroids[j])) {

                        var selected_index = -1;

                        for (var k = 0; k < selected_ships.length; k++) {
                            if (selected_ships[k].id == i)
                                selected_index = k;
                            if (selected_ships[k].id > i)
                                selected_ships[k].id--;
                        }

                        if (selected_index >= 0)
                            selected_ships.splice(selected_index, 1);

                        ships.splice(i, 1);

                        break;
                    }
                }
            }

            // ASTEROID DYNAMICS 
            for (var i = 0; i < asteroids.length; i++) {
                asteroids[i].x += dt * asteroids[i].vx;
                asteroids[i].y += dt * asteroids[i].vy;

                if (asteroids[i].x > game_width)
                    asteroids[i].x -= game_width;
                if (asteroids[i].y > game_height)
                    asteroids[i].y -= game_height;
                if (asteroids[i].x < 0)
                    asteroids[i].x += game_width;
                if (asteroids[i].y < 0)
                    asteroids[i].y += game_height;

                asteroids[i].angle += dt * asteroids[i].omega;
            }
            

            // BULLET DYNAMICS
            var bullet_damage = 1;
            var minimum_asteroid_radius = 80;
            var bullet_duration = 3000;

            for (var i = 0; i < bullets.length; i++) {
                bullets[i].x += bullets[i].vx * dt;
                bullets[i].y += bullets[i].vy * dt;

                if (bullets[i].x > game_width)
                    bullets[i].x -= game_width;
                if (bullets[i].y > game_height)
                    bullets[i].y -= game_height;
                if (bullets[i].x < 0)
                    bullets[i].x += game_width;
                if (bullets[i].y < 0)
                    bullets[i].y += game_height;

                if ((new Date()).getTime() - bullets[i].fire_time > bullet_duration) {
                    bullets.splice(i, 1);
                    continue;
                }

                for (var j = 0; j < asteroids.length; j++) {
                    if (point_in_asteroid(bullets[i].x, bullets[i].y, asteroids[j])) {
                        bullets.splice(i, 1);

                        asteroids[j].health -= bullet_damage;

                        if (asteroids[j].health < 0) {
                            for (var z = 0; z < ships.length; z++)
                                if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.asteroid == j)
                                    ships[z].target.active = false;

                            var asteroid_radius = asteroids[j].size;
                            var pos = { x: asteroids[j].x, y: asteroids[j].y };
                            asteroids.splice(j, 1);

                            if (asteroid_radius > minimum_asteroid_radius) {
                                for (var i = 0; i < 4; i++) {
                                    create_asteroid(pos, asteroid_radius / 1.25);
                                }
                            }

                            game_score += Math.floor(asteroid_radius);

                            document.getElementById("score").innerHTML = "<h1>" + game_score + "</h1>";
                        }

                        break;
                    }
                }
            }
        }

        var command_count = 0;
        var selected_ships = [];

        function handle_input() {
            var ship_select_radius = Math.sqrt(ship_graphic.width * ship_graphic.width + ship_graphic.height * ship_graphic.height) / 2.0;

            if (mouse.is_clicked == 0 && mouse.mode == "select") {

                if (!(16 in keyboard)) {
                    selected_ships = [];
                }

                for (var i = 0; i < ships.length; i++) {
                    var dx = ships[i].x - mouse.x;
                    var dy = ships[i].y - mouse.y;

                    if (dx * dx + dy * dy < ship_select_radius * ship_select_radius) 
                        selected_ships.push({ id: i });
                }
            }

            if (mouse.is_clicked == 0 && mouse.mode == "attack") {

                var selected_asteroid = -1;

                for (var i = 0; i < asteroids.length; i++) {
                    if (point_in_asteroid(mouse.x, mouse.y, asteroids[i]))
                        selected_asteroid = i;
                }

                for (var i = 0; i < selected_ships.length; i++) {
                    if (selected_asteroid < 0) {
                        ships[selected_ships[i].id].target = {
                            x: mouse.x, y: mouse.y,
                            active: true, command_id: command_count,
                            mode: "attack-move"
                        };
                    } else {
                        ships[selected_ships[i].id].target = {
                            asteroid: selected_asteroid,
                            active: true, command_id: command_count,
                            mode: "attack"
                        };
                    }
                }

                if (selected_asteroid < 0)
                    create_click_marker(mouse.x, mouse.y, { r: 255, g: 0, b: 0 });

                command_count++;

                mouse.mode = "select";
            }

            if (mouse.is_down == 0 && mouse.is_dragging) {
                selected_ships = []

                var min_mouse_x = Math.min(mouse.x, mouse.down_x);
                var min_mouse_y = Math.min(mouse.y, mouse.down_y);

                var max_mouse_x = Math.max(mouse.x, mouse.down_x);
                var max_mouse_y = Math.max(mouse.y, mouse.down_y);

                for (var i = 0; i < ships.length; i++) {
                    if (ships[i].x > min_mouse_x && ships[i].x < max_mouse_x &&
                        ships[i].y > min_mouse_y && ships[i].y < max_mouse_y)
                        selected_ships.push({ id: i });
                }

                graphics.beginPath();

                graphics.fillStyle = "#0000FF"
                graphics.globalAlpha = 0.2;

                graphics.fillRect(
                    min_mouse_x,
                    min_mouse_y,
                    max_mouse_x - min_mouse_x,
                    max_mouse_y - min_mouse_y);

                graphics.globalAlpha = 1.0
            }

            if (mouse.is_clicked == 2 && selected_ships.length > 0 && mouse.mode == "select") {

                var selected_asteroid = -1;

                for (var i = 0; i < asteroids.length; i++) {
                    if (point_in_asteroid(mouse.x, mouse.y, asteroids[i]))
                        selected_asteroid = i;
                }

                for (var i = 0; i < selected_ships.length; i++) {
                    if (selected_asteroid < 0) {
                        ships[selected_ships[i].id].target = {
                            x: mouse.x, y: mouse.y,
                            active: true, command_id: command_count,
                            mode: "move"
                        };

                    } else {
                        ships[selected_ships[i].id].target = {
                            asteroid: selected_asteroid,
                            active: true, command_id: command_count,
                            mode: "attack"
                        };
                    }
                }

                if(selected_asteroid < 0)
                    create_click_marker(mouse.x, mouse.y, { r: 0, g: 255, b: 0 });

                command_count++;
            }

            if (mouse.is_clicked == 2 && mouse.mode == "attack") {
                mouse.mode = "select";
            }


            mouse.is_clicked = -1;
        } 

        initialize_game_data();
    </script>
</bodyoncontextmenu="return">
