<!DOCTYPE html>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
<style>
    * {
        font-family: sans-serif;
        font-size: 14px;
    }

    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        z-index: 1;
    }

    h1 {
        font-family: "Montserrat", sans-serif;
        font-size: 32px;
        margin: 1%;
        %text-shadow: 3px 3px #000000;
    }
    
    h2 {
        font-family: "Montserrat", sans-serif;
        font-size: 24px;
        margin: 1%;
        %text-shadow: 3px 3px #000000;
    }

    p {
        font-family: "Montserrat", sans-serif;
        font-size: 20px;
        margin: 1%;
        %text-shadow: 3px 3px #000000;
    }

    span {
        font-family: "Montserrat", sans-serif;
        margin: 1%;
        font-size: 20px;
        %text-shadow: 3px 3px #000000;
    }

    #score-container {
        position: absolute;
        width: 200px;
        background: none;
        color: #FFFFFF;
        border: #FFFFFF;
        margin: 10px;
        padding: 10px;
        z-index: 2;
        pointer-events: none;
    }

    #score {
        position: absolute;
        width: 200px;
        background: none;
        color: #FFFFFF;
        border: #FFFFFF;
        margin: 0px;
        padding: 0px;
        z-index: 2;
    }

    #level {
        position: absolute;
        right: 0px;
        width: 150px;
        background: none;
        color: #FFFFFF;
        border: #FFFFFF;
        margin: 10px;
        padding: 10px;
        z-index: 2;
        pointer-events: none;
    }

    #start-screen {
        position: absolute;
        margin: 25% 50%;
        width: 700px;
        background: #181818;
        color: #EEEEEE;
        border: none;
        transform: translate(-50%,-50%);
        padding: 0;
        z-index: 3;
        pointer-events: none;
    }

    #controls-screen {
        position: absolute;
        margin: 24.5% 0%;
        width: 360px;
        background: #181818;
        color: #EEEEEE;
        border: none;
        padding: 25px;
        z-index: 3;
        transform: translate(0%, -50%);
        pointer-events: none;
    }

    #death-screen {
        position: absolute;
        margin: 25% 50%;
        width: 700px;
        background: #181818;
        color: #EEEEEE;
        border: none;
        transform: translate(-50%,-50%);
        padding: 20px;
        z-index: 3;
    }

    #high-score-screen {
        position: absolute;
        margin: 25% 100%;
        width: 250px;
        background: #181818;
        color: #EEEEEE;
        border: none;
        padding: 25px;
        z-index: 3;
        transform: translate(-100%, -50%);
        pointer-events: none;
    }

    #pause-screen {
        position: absolute;
        margin: 25% 50%;
        width: 700px;
        background: #181818;
        color: #EEEEEE;
        border: none;
        transform: translate(-50%,0);
        padding: 0;
        z-index: 3;
        pointer-events: none;
    }

    .row {
        display: flex;
    }

    .column {
        flex: 50%;
        padding: 10px;
    }

    .gameMenuButton {
        background-color: #003fb6;
        text-shadow: 3px 3px #000000;
        box-shadow: 5px 5px #000000;
        color: #FFFFFF;
        border: none;
        width: 300px;
        display: inline-block;
        padding: 6px 24px;
        z-index: 2;
        text-decoration: none;
        cursor: pointer;
    }

    .gameMenuButton:hover {
        background-color: #0045c7;
    }

        .gameMenuButton:active {
            position: relative;
            top: 2px;
            left: 2px;
            box-shadow: 3px 3px #000000;
        }
</style>


<head>
    <meta charset="utf-8" />
    <title>Asteroids RTS</title>
</head>

<body oncontextmenu="return false">

    <div id="start-screen">
        <center>
            <h1><span style="color:cadetblue;font-size: 32px;font-weight: bold;">Asteroid</span><span style="color:orangered;font-size: 32px;font-weight: bold;">Craft</span></h1>
            <h2>Forty years ago we lost a <span style="color:blueviolet;font-size: 24px;font-weight: bold;">huge</span> number of ships in this asteroid field</h2> <br />
            <h2>From low resolution images we received, it seems like the asteroids contain lots of <span style="color:blueviolet;font-size: 24px;font-weight: bold;">points</span></h2> <br />
            <h2>Take command of a mining party to go explore the sector and get them</h2> <br />
            <h2><span style="color:dodgerblue;font-size: 24px;font-weight: bold;">Click Anywhere Begin!</span></h2>
        </center>
    </div>

    <div id="controls-screen">
        <h2>Controls</h2> <br />
        <p><span>Mouse wraps around the screen</span></p>
        <p><span style="color:forestgreen">Left Click (Ship):</span> <span style="color:deepskyblue">Select</span></p>
        <p><span style="color:forestgreen">Left Drag:</span> <span style="color:deepskyblue">Select</span></p>
        <p><span style="color:yellowgreen">Shift</span> + <span style="color:forestgreen">Select:</span> <span style="color:deepskyblue">Add to Selection</span></p>
        <p><span style="color:cornflowerblue">Left Click (Background):</span> <span style="color:deepskyblue">Unselect</span></p>
        <p><span style="color:cornflowerblue">Right Click (Background):</span> <span style="color:deepskyblue">Move</span></p>
        <p><span style="color:red">Right Click (Enemy):</span> <span style="color:deepskyblue">Attack</span></p>
        <p><span style="color:red">A + Left Click:</span> <span style="color:deepskyblue">Attack Move</span></p>
        <p><span style="color:yellowgreen">Control:</span> <span style="color:deepskyblue">Show Controls</span></p>
        <p><span style="color:yellowgreen">Escape:</span> <span style="color:deepskyblue">Pause</span></p>
        <p><span style="color:yellowgreen">M:</span> <span style="color:deepskyblue">Toggle Music</span></p>
        <p><span style="color:yellowgreen">S:</span> <span style="color:deepskyblue">Toggle SFX</span></p>
    </div>

    <div id="death-screen">
        <center>
            <h1>Your Party Died!</h1><br />
            <h2>You got <span style="color:dodgerblue;font-size: 24px;font-weight: bold;">{points}</span> points and reached level <span style="color:forestgreen;font-size: 24px;font-weight: bold;">{level}</span></h2>
            <div id="high-score-option"><h2><span style="color:greenyellow;font-size: 24px;font-weight: bold;">Congratulations!</span> You Got A High Score!</h2><br /><input type="text" value="Name" name="nameInput" id="nameInput" style="color: #888; font-size: 28px" onfocus="high_score_name_focus(this)" onblur="high_score_name_blur(this)"><br /><br /></div>
            <div id="no-high-score-option"><h2>Your <span style="color:red;font-size: 24px;font-weight: bold;">score</span> wasn't high enough!</h2><br /></div>
            <a href="#" onclick="restart_game()" class="gameMenuButton"><p>Try Again!</p></a>
        </center>
    </div>

    <div id="high-score-screen">
        <h2>High Scores</h2><br />
    </div>

    <div id="pause-screen">
        <center>
            <h1 style="color:dodgerblue">Paused</h1> <br />
            <p>(Click Anywhere To Continue)</p>
        </center>
    </div>

    <div id="score-container">
        <div id="score"><h1>0</h1></div>
    </div>

    <div id="level"><h1>Level: 1</h1></div>

    <canvas id="cvs"></canvas>

    <script type="text/javascript">

        document.onmousedown = disable_click;
        $("#pause-screen")[0].style.display = "none";
        $("#death-screen")[0].style.display = "none";

        function disable_click(event) {
            if (event.button == 2) {
                return false;
            }
        }

        $(window).resize(function () {
            game_width = window.innerWidth;
            game_height = window.innerHeight;
            canvas.width = game_width;
            canvas.height = game_height;
        });

        function high_score_name_focus(i) {
            if (i.value == i.defaultValue) { i.value = ""; i.style.color = "#000"; }
        }

        function high_score_name_blur(i) {
            if (i.value == "") { i.value = i.defaultValue; i.style.color = "#888"; }
        }

        var game_width = window.innerWidth;
        var game_height = window.innerHeight;

        var game_score = 0;
        var game_level = 1;
        var game_state = "start-screen";

        var cached_death_html = $("#death-screen")[0].innerHTML;

        var canvas = document.getElementById("cvs");
        canvas.width = game_width;
        canvas.height = game_height;

        canvas.oncontextmenu = function () { return false; }

        var graphics = canvas.getContext("2d");

        var render_frame_rate = 1000.0 / 60.0;

        var last_frame = (new Date().getTime());

        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, render_frame_rate);
                };
        })();

        function game_loop() {
            if (game_state != "paused")
                requestAnimFrame(game_loop);

            dt = (new Date()).getTime() - last_frame;
            last_frame = (new Date()).getTime();

            draw_game();
            update_game(dt);

            handle_input();
        };

        function restart_game() {
            for (var i = 0; i < high_score_list.length; i++) {
                if (game_score > high_score_list[i].score) {
                    high_score_list[i].name = $("#nameInput")[0].value;
                    high_score_list[i].score = game_score;
                    break;
                }
            }

            save_high_scores();
            update_high_score_list();

            game_state = "start-screen";
            game_score = 0;
            game_level = 1;

            initialize_start_screen();
            $("#death-screen")[0].style.display = "none";
            $("#death-screen")[0].innerHTML = cached_death_html;
            $("#controls-screen")[0].style.display = "block";
            $("#start-screen")[0].style.display = "block";

            canvas.onclick = function () {
                if (!mouse.is_locked) {
                    canvas.request_pointer_lock();
                }
            }
        }

        /* IO CODE */
        var mouse = {
            x: 0.0,
            y: 0.0,
            down_x: 0.0,
            down_y: 0.0,
            unwrapped_x: 0.0,
            unwrapped_y: 0.0,
            is_down: -1,
            is_clicked: -1,
            is_dragging: false,
            down_time: -1,
            click_time_left: 135,
            click_time_right: 200,
            mode: "select",
            is_locked: false
        };

        mouse.selected_image = new Image();
        mouse.selected_image.src = "graphics/mouse_select.svg";

        mouse.attack_image = new Image();
        mouse.attack_image.src = "graphics/mouse_attack.svg";

        canvas.addEventListener(
            "mousemove",
            function (input) {
                if (mouse.is_locked) {
                    mouse.x += input.movementX;
                    mouse.y += input.movementY;

                    if (mouse.is_down >= 0) {
                        mouse.unwrapped_x += input.movementX;
                        mouse.unwrapped_y += input.movementY;
                    }

                    if (mouse.x > game_width)
                        mouse.x -= game_width;
                    if (mouse.x < 0)
                        mouse.x += game_width;

                    if (mouse.y > game_height)
                        mouse.y -= game_height;
                    if (mouse.y < 0)
                        mouse.y += game_height;

                    if (mouse.is_down != -1 && !mouse.is_dragging) {
                        var dist_sq = (mouse.x - mouse.down_x) * (mouse.x - mouse.down_x) + (mouse.y - mouse.down_y) * (mouse.y - mouse.down_y);
                        var min_click_dist_sq = 40 * 40;

                        if (dist_sq > min_click_dist_sq)
                            mouse.is_dragging = true;
                    }
                } else {
                    mouse.x = input.x;
                    mouse.y = input.y;
                }
            }, false);

        canvas.addEventListener(
            "mousedown",
            function (input) {
                mouse.is_down = input.button;
                mouse.down_time = (new Date()).getTime();
                mouse.down_x = mouse.x;
                mouse.down_y = mouse.y;

                mouse.unwrapped_x = mouse.x;
                mouse.unwrapped_y = mouse.y;

                mouse.is_dragging = false;
            }, false);

        canvas.addEventListener(
            "mouseup",
            function (input) {
                var dist_sq = (mouse.x - mouse.down_x) * (mouse.x - mouse.down_x) + (mouse.y - mouse.down_y) * (mouse.y - mouse.down_y);
                var min_click_distance = 40 * 40;

                if (mouse.is_down == 0 && !mouse.is_dragging)
                    mouse.is_clicked = mouse.is_down;

                if (mouse.is_down == 2)
                    mouse.is_clicked = mouse.is_down;

                mouse.is_down = -1;
                mouse.down_time = -1;
            }, false);

        canvas.onclick = function () {
            if (!mouse.is_locked) {
                canvas.request_pointer_lock();
            }
        }

        canvas.request_pointer_lock = canvas.requestPointerLock ||
            canvas.mozRequestPointerLock ||
            canvas.webkitRequestPointerLock;

        document.exit_pointer_lock = document.exitPointerLock ||
            document.mozExitPointerLock ||
            document.webkitExitPointerLock;

        document.addEventListener("pointerlockchange", pointer_lock_change, false);
        document.addEventListener("mozpointerlockchange", pointer_lock_change, false);
        document.addEventListener("webkitpointerlockchange", pointer_lock_change, false);

        function pointer_lock_change(e) {
            if (document.pointerLockElement == canvas ||
                document.mosPointerLockElement == canvas ||
                document.webkitPointerLockElement == canvas) {

                canvas.onclick = null;
                mouse.is_locked = true;

                if (game_state == "start-screen") {
                    $("#start-screen")[0].style.display = "none";
                    $("#controls-screen")[0].style.display = "none";
                    $("#high-score-screen")[0].style.display = "none";
                    game_state = "play";
                    game_level = 1;
                    initialize_game_data();
                }

                if (game_state == "paused") {
                    $("#pause-screen")[0].style.display = "none";
                    game_state = "play";
                    last_frame = (new Date().getTime());
                    game_loop();
                }
            } else {
                if (game_state != "dead") {
                    canvas.onclick = function () {
                        canvas.request_pointer_lock();
                    }
                }

                mouse.is_locked = false;

                if (game_state == "play") {
                    game_state = "paused";
                    $("#pause-screen")[0].style.display = "block";
                }
            }
        }

        function draw_mouse() {
            graphics.save();

            graphics.translate(mouse.x, mouse.y);

            if (mouse.mode == "select")
                graphics.drawImage(mouse.selected_image, 0, 0);
            else if (mouse.mode == "attack")
                graphics.drawImage(mouse.attack_image, -mouse.attack_image.width / 2.0, -mouse.attack_image.height / 2.0);

            graphics.restore();
        }

        keyboard = { ATTACK_KEY: 65, CONTROLS_KEY: 17 };

        document.body.addEventListener(
            "keydown",
            function (input) {
                keyboard[input.keyCode] = true;

                if (input.keyCode == keyboard.ATTACK_KEY && selected_ships.length > 0)
                    mouse.mode = "attack";

                if (input.keyCode == keyboard.CONTROLS_KEY && game_state != "start-screen")
                    $("#controls-screen")[0].style.display = "block";

                if (input.keyCode == 77) {
                    music_enabled = !music_enabled;
                    if (!music_enabled)
                        stop_song();
                    if (music_enabled)
                        play_song();
                }

                if (input.keyCode == 83) {
                    sfx_enabled = !sfx_enabled;
                }
            }, false);

        document.body.addEventListener(
            "keyup",
            function (input) {
                if (input.keyCode == keyboard.CONTROLS_KEY && game_state != "start-screen")
                    $("#controls-screen")[0].style.display = "none";

                delete keyboard[input.keyCode];
            }, false);

        /* SHIP CODE */
        var ship_graphic = new Image();
        var ship_graphic_loaded = false;
        ship_graphic.src = "graphics/ship.svg";
        ship_graphic.radius = -1;
        ship_graphic.addEventListener(
            "load",
            function () {
                ship_graphic_loaded = true;
                ship_graphic.radius = Math.sqrt(
                    ship_graphic.width * ship_graphic.width + ship_graphic.height * ship_graphic.height) / 2.0;
            }
        );

        var ship_fire_sounds = [
            new sound("sounds/laser_1.wav"),
            new sound("sounds/laser_2.wav"),
            new sound("sounds/laser_3.wav"),
            new sound("sounds/laser_4.wav")
        ];

        for (var i = 0; i < ship_fire_sounds.length;i++)
            ship_fire_sounds[i].sound.volume = 0.2;

        var selected_ships = [];
        var ships = [];

        function draw_ship(ship, offset) {
            var color = "#1ef9de";
            var size = 20.0;

            graphics.save();

            graphics.translate(ship.x + offset.x, ship.y + offset.y);
            graphics.rotate(ship.angle);

            if (ship_graphic_loaded)
                graphics.drawImage(ship_graphic, -ship_graphic.width / 2.0, -ship_graphic.height / 2.0);

            graphics.restore();
        }

        function draw_ship_selector(ship, ship_selector) {
            var color = "#FFFFFF";
            var size = 10.0;

            graphics.save();

            graphics.translate(ship.x, ship.y);

            graphics.strokeStyle = color;
            graphics.lineWidth = 2;

            graphics.beginPath();

            graphics.moveTo(-ship_graphic.width / 2.0, -ship_graphic.height / 2.0 + size);
            graphics.lineTo(-ship_graphic.width / 2.0, -ship_graphic.height / 2.0);
            graphics.lineTo(-ship_graphic.width / 2.0 + size, -ship_graphic.height / 2.0);

            graphics.moveTo(ship_graphic.width / 2.0, -ship_graphic.height / 2.0 + size);
            graphics.lineTo(ship_graphic.width / 2.0, -ship_graphic.height / 2.0);
            graphics.lineTo(ship_graphic.width / 2.0 - size, -ship_graphic.height / 2.0);

            graphics.moveTo(ship_graphic.width / 2.0, ship_graphic.height / 2.0 - size);
            graphics.lineTo(ship_graphic.width / 2.0, ship_graphic.height / 2.0);
            graphics.lineTo(ship_graphic.width / 2.0 - size, ship_graphic.height / 2.0);

            graphics.moveTo(-ship_graphic.width / 2.0, ship_graphic.height / 2.0 - size);
            graphics.lineTo(-ship_graphic.width / 2.0, ship_graphic.height / 2.0);
            graphics.lineTo(-ship_graphic.width / 2.0 + size, ship_graphic.height / 2.0);

            graphics.stroke();

            graphics.restore();
        }


        function move(ship) {
            var dx = ship.target.x - ship.x;
            var dy = ship.target.y - ship.y;

            if (Math.abs(dx) > game_width / 2.0)
                dx -= Math.sign(dx) * game_width;
            if (Math.abs(dy) > game_height / 2.0)
                dy -= Math.sign(dy) * game_height;

            var norm = Math.sqrt(dx * dx + dy * dy);

            if (norm < game_parameters.ship_speed * dt)
                norm = game_parameters.ship_speed * dt;

            if (norm < game_parameters.min_ship_to_target) {
                ship.target.active = false;
            } else {
                ship.x += dx / norm * game_parameters.ship_speed * dt;
                ship.y += dy / norm * game_parameters.ship_speed * dt;

                if (ship.x > game_width)
                    ship.x -= game_width;
                if (ship.x < 0)
                    ship.x += game_width;
                if (ship.y > game_height)
                    ship.y -= game_height;
                if (ship.y < 0)
                    ship.y += game_height;

                ship.angle = Math.atan2(dy, dx) + Math.PI / 2.0;
            }

            return ship
        }

        function attack(ship, target) {
            var dx = target.x - ship.x;
            var dy = target.y - ship.y;

            if (Math.abs(dx) > game_width / 2.0)
                dx -= Math.sign(dx) * game_width;
            if (Math.abs(dy) > game_height / 2.0)
                dy -= Math.sign(dy) * game_height;

            var norm = Math.sqrt(dx * dx + dy * dy);

            if (norm > game_parameters.ship_attack_range) {
                ship.x += dx / norm * game_parameters.ship_speed * dt;
                ship.y += dy / norm * game_parameters.ship_speed * dt;

                if (ship.x > game_width)
                    ship.x -= game_width;
                if (ship.x < 0)
                    ship.x += game_width;
                if (ship.y > game_height)
                    ship.y -= game_height;
                if (ship.y < 0)
                    ship.y += game_height;

                ship.angle = Math.atan2(dy, dx) + Math.PI / 2.0;
            } else {
                ship.angle = Math.atan2(dy, dx) + Math.PI / 2.0;

                if ((new Date()).getTime() - ship.last_fired > game_parameters.ship_fire_rate) {
                    bullets.push({
                        x: ship.x + ship_graphic.radius * dx / norm,
                        y: ship.y + ship_graphic.radius * dy / norm,
                        vx: dx / norm * game_parameters.bullet_speed,
                        vy: dy / norm * game_parameters.bullet_speed,
                        fire_time: (new Date()).getTime(),
                        player: true
                    });

                    ship.last_fired = (new Date()).getTime();

                    play_ship_fire();
                }
            }

            return ship
        }

        /* ENEMY CODE */
        var enemy_ships = [];

        var enemy_graphic = new Image();
        var enemy_graphic_loaded = false;
        enemy_graphic.src = "graphics/enemy.svg";
        enemy_graphic.radius = -1;
        enemy_graphic.addEventListener(
            "load",
            function () {
                enemy_graphic_loaded = true;
                enemy_graphic.radius = Math.sqrt(
                    enemy_graphic.width * enemy_graphic.width + enemy_graphic.height * enemy_graphic.height) / 2.0;
            }
        );

        function draw_enemy(ship, offset) {
            var color = "#1ef9de";
            var size = 20.0;

            graphics.save();

            graphics.translate(ship.x + offset.x, ship.y + offset.y);

            if (enemy_graphic_loaded)
                graphics.drawImage(enemy_graphic, -enemy_graphic.width / 2.0, -enemy_graphic.height / 2.0);

            graphics.restore();
        }

        function create_enemy_ship(x, y) {
            enemy_ships.push(
                {
                    x: x,
                    y: y,
                    target: null,
                    target_type: "",
                    last_fired: 0,
                    max_radius: enemy_graphic.radius
                });
        }

        function update_enemy_ships(dt) {
            var enemy_attack_range = 600;
            var enemy_speed = 0.1;
            var enemy_fire_rate = 400;

            for (var i = 0; i < enemy_ships.length; i++) {

                var enemy_dx = 0.0;
                var enemy_dy = 0.0;

                if (!enemy_ships[i].target) {
                    if (ships.length > 0) {
                        var ship_index = Math.floor(Math.random() * ships.length);

                        enemy_ships[i].target = ship_index;
                        enemy_ships[i].target_type = "ship";
                    } else if (asteroids.length > 0) {
                        var asteroid_index = Math.floor(Math.random() * asteroids.length);

                        enemy_ships[i].target = asteroid_index;
                        enemy_ships[i].target_type = "asteroid";
                    } else {
                        continue;
                    }
                }

                var target = enemy_ships[i].target_type == "ship" ? ships[enemy_ships[i].target] : asteroids[enemy_ships[i].target];

                var dx = target.x - enemy_ships[i].x;
                var dy = target.y - enemy_ships[i].y;

                if (Math.abs(dx) > game_width / 2.0)
                    dx -= Math.sign(dx) * game_width;
                if (Math.abs(dy) > game_height / 2.0)
                    dy -= Math.sign(dy) * game_height;

                var norm = Math.sqrt(dx * dx + dy * dy);

                if (norm < enemy_attack_range) {
                    if ((new Date()).getTime() - enemy_ships[i].last_fired > enemy_fire_rate) {
                        bullets.push({
                            x: enemy_ships[i].x + enemy_graphic.radius * dx / norm,
                            y: enemy_ships[i].y + enemy_graphic.radius * dy / norm,
                            vx: dx / norm * game_parameters.bullet_speed,
                            vy: dy / norm * game_parameters.bullet_speed,
                            fire_time: (new Date()).getTime(),
                            player: false
                        });

                        enemy_ships[i].last_fired = (new Date()).getTime();

                        play_ship_fire();
                    }
                } else {
                    enemy_dx += dx / norm * enemy_speed * dt;
                    enemy_dy += dy / norm * enemy_speed * dt;
                }

                for (var j = 0; j < asteroids.length; j++) {
                    var dx = enemy_ships[i].x - asteroids[j].x;
                    var dy = enemy_ships[i].y - asteroids[j].y;

                    if (Math.abs(dx) > game_width / 2.0)
                        dx -= Math.sign(dx) * game_width;
                    if (Math.abs(dy) > game_height / 2.0)
                        dy -= Math.sign(dy) * game_height;

                    var norm = Math.sqrt(dx * dx + dy * dy);

                    if (norm < asteroids[j].max_radius * 1.2) {
                        enemy_dx += dx / norm * enemy_speed * dt;
                        enemy_dy += dy / norm * enemy_speed * dt;
                    }
                }

                enemy_ships[i].x += enemy_dx;
                enemy_ships[i].y += enemy_dy;

                if (enemy_ships[i].x > game_width)
                    enemy_ships[i].x -= game_width;
                if (enemy_ships[i].x < 0)
                    enemy_ships[i].x += game_width;
                if (enemy_ships[i].y > game_height)
                    enemy_ships[i].y -= game_height;
                if (enemy_ships[i].y < 0)
                    enemy_ships[i].y += game_height;

            }
        }

        function point_in_enemy(x, y, enemy) {
            var dx = x - enemy.x;
            var dy = y - enemy.y;

            if (dx * dx + dy * dy < enemy.max_radius * enemy.max_radius)
                return true;

            return false;
        }

        /* ASTEROID CODE */
        function draw_asteroid(asteroid, offset) {
            var color = "#AAAAAA";

            graphics.lineWidth = 4;
            graphics.strokeStyle = color;

            graphics.save();
            graphics.translate(asteroid.x + offset.x, asteroid.y + offset.y);
            graphics.rotate(asteroid.angle);

            graphics.beginPath();
            graphics.moveTo(asteroid.vertices[0].x, asteroid.vertices[0].y);

            for (var i = 0; i < asteroid.vertices.length; i++) {
                graphics.lineTo(asteroid.vertices[i].x, asteroid.vertices[i].y);
            }

            graphics.lineTo(asteroid.vertices[0].x, asteroid.vertices[0].y);

            graphics.stroke();
            graphics.restore();

        }

        function draw_periodic(drawable, draw_func) {
            draw_func(drawable, { x: 0.0, y: 0.0 });

            var buffer = drawable.max_radius;

            for (var dx = -1; dx <= 1; dx++) {
                for (var dy = -1; dy <= 1; dy++) {
                    if (dx == 0 && dy == 0)
                        continue;

                    var offset = { x: 0.0, y: 0.0 };

                    if (dx == -1 && drawable.x < buffer)
                        offset.x += game_width;

                    if (dx == 1 && drawable.x > game_width - buffer)
                        offset.x -= game_width;

                    if (dy == -1 && drawable.y < buffer)
                        offset.y += game_height;

                    if (dy == 1 && drawable.y > game_height - buffer)
                        offset.y -= game_height;

                    draw_func(drawable, offset);
                }
            }

        }

        function point_in_asteroid_image(x, y, asteroid, offset) {
            var intersections = 0;

            var c_theta = Math.cos(asteroid.angle);
            var s_theta = Math.sin(asteroid.angle);

            asteroid.x += offset.x;
            asteroid.y += offset.y;

            if (Math.abs(x - asteroid.x) > game_width / 2.0)
                x -= Math.sign(x - asteroid.x);
            if (Math.abs(y - asteroid.y) > game_height / 2.0)
                y -= Math.sign(y - asteroid.y);

            var v_old = {
                x: asteroid.x + c_theta * asteroid.vertices[0].x - s_theta * asteroid.vertices[0].y,
                y: asteroid.y + s_theta * asteroid.vertices[0].x + c_theta * asteroid.vertices[0].y
            }

            for (var i = 1; i <= asteroid.vertices.length; i++) {
                var index = i % asteroid.vertices.length;

                var v = {
                    x: asteroid.x + c_theta * asteroid.vertices[index].x - s_theta * asteroid.vertices[index].y,
                    y: asteroid.y + s_theta * asteroid.vertices[index].x + c_theta * asteroid.vertices[index].y
                }

                var t_2 = (y - v_old.y) / (v.y - v_old.y);
                var t_1 = -(x - v_old.x) + t_2 * (v.x - v_old.x);

                v_old = v;

                if (t_2 < 0 || t_2 > 1)
                    continue;

                if (t_1 >= 0)
                    intersections++;
            }

            return intersections % 2 == 1;
        }

        function point_in_asteroid(x, y, asteroid) {

            if (point_in_asteroid_image(x, y, asteroid, { x: 0.0, y: 0.0 }))
                return true;

            var buffer = asteroid.max_radius;

            for (var dx = -1; dx <= 1; dx++) {
                for (var dy = -1; dy <= 1; dy++) {
                    if (dx == 0 && dy == 0)
                        continue;

                    var offset = { x: 0.0, y: 0.0 };

                    if (dx == -1 && asteroid.x < buffer)
                        offset.x += game_width;

                    if (dx == 1 && asteroid.x > game_width - buffer)
                        offset.x -= game_width;

                    if (dy == -1 && asteroid.y < buffer)
                        offset.y += game_height;

                    if (dy == 1 && asteroid.y > game_height - buffer)
                        offset.y -= game_height;

                    if (point_in_asteroid_image(x, y, asteroid, offset))
                        return true;
                }
            }

            return false;
        }

        // NOTE(schsam): For now we will do asteroid-disk collision, but this
        // might not be great. If so, we can implement different kinds of
        // collision for different kinds of objects separately.
        function ship_asteroid_intersection_image(ship, asteroid, offset) {
            var c_theta = Math.cos(asteroid.angle);
            var s_theta = Math.sin(asteroid.angle);

            asteroid.x += offset.x;
            asteroid.y += offset.y;

            var v_old = {
                x: asteroid.x + c_theta * asteroid.vertices[0].x - s_theta * asteroid.vertices[0].y,
                y: asteroid.y + s_theta * asteroid.vertices[0].x + c_theta * asteroid.vertices[0].y
            }

            var r_sqr = ship.max_radius * ship.max_radius;

            for (var i = 1; i <= asteroid.vertices.length; i++) {
                var index = i % asteroid.vertices.length;

                var v = {
                    x: asteroid.x + c_theta * asteroid.vertices[index].x - s_theta * asteroid.vertices[index].y,
                    y: asteroid.y + s_theta * asteroid.vertices[index].x + c_theta * asteroid.vertices[index].y
                }

                //l = l_0 + t(l_1 - l_0).
                //(l - r)^2 = R^2
                //(l_0 - r)^2 + 2t(l_1 - l_0).(l_0 - r) + t^2(l_1 - l_0)^2 - R^2 = 0
                var a = (v.x - v_old.x) * (v.x - v_old.x) + (v.y - v_old.y) * (v.y - v_old.y);
                var b = 2 * ((v.x - v_old.x) * (v_old.x - ship.x) + (v.y - v_old.y) * (v_old.y - ship.y));
                var c = (ship.x - v_old.x) * (ship.x - v_old.x) + (ship.y - v_old.y) * (ship.y - v_old.y) - r_sqr;

                var disc = (b * b - 4 * a * c);

                if (disc <= 0)
                    continue;

                var t_1 = (-b + Math.sqrt(disc)) / (2 * a);
                var t_2 = (-b - Math.sqrt(disc)) / (2 * a);

                v_old = v;

                if ((t_1 < 0 || t_1 > 1) && (t_2 < 0 || t_2 > 1))
                    continue;

                return true;
            }

            return false;
        }

        function ship_asteroid_intersection(ship, asteroid) {

            if (ship_asteroid_intersection_image(ship, asteroid, { x: 0.0, y: 0.0 }))
                return true;

            var buffer = asteroid.max_radius;

            for (var dx = -1; dx <= 1; dx++) {
                for (var dy = -1; dy <= 1; dy++) {
                    if (dx == 0 && dy == 0)
                        continue;

                    var offset = { x: 0.0, y: 0.0 };

                    if (dx == -1 && asteroid.x < buffer)
                        offset.x += game_width;

                    if (dx == 1 && asteroid.x > game_width - buffer)
                        offset.x -= game_width;

                    if (dy == -1 && asteroid.y < buffer)
                        offset.y += game_height;

                    if (dy == 1 && asteroid.y > game_height - buffer)
                        offset.y -= game_height;

                    if (ship_asteroid_intersection_image(ship, asteroid, offset))
                        return true;
                }
            }

            return false;
        }

        function create_asteroid(position, size) {
            var vertices = [];
            var angle = 0.0;
            var d_angle_scale = 0.5;
            var d_radius_scale = 0.5;
            var max_radius = 0.0;

            while (angle < 2 * Math.PI) {
                angle += 0.2 + d_angle_scale * Math.random();

                if (angle > 2 * Math.PI)
                    break;

                var radius = size + d_radius_scale * size * (Math.random() - 0.5);

                if (radius > max_radius)
                    max_radius = radius;

                vertices.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            asteroids.push(
                {
                    x: position.x, y: position.y,
                    angle: 0.0,
                    vx: game_parameters.asteroid_velocity_scale * (Math.random() - 0.5) / size,
                    vy: game_parameters.asteroid_velocity_scale * (Math.random() - 0.5) / size,
                    omega: game_parameters.asteroid_omega_scale * (Math.random() - 0.5),
                    vertices: vertices,
                    size: size,
                    health: size / 3.0,
                    max_radius: max_radius
                });
        }

        var asteroids = [];

        // BULLETS
        var bullet_graphic = new Image();
        var bullet_graphic_loaded = false;
        bullet_graphic.src = "graphics/bullet.svg";
        bullet_graphic.radius = -1;
        bullet_graphic.addEventListener(
            "load",
            function () {
                bullet_graphic_loaded = true;
                bullet_graphic.radius = Math.sqrt(bullet_graphic.width * bullet_graphic.width + bullet_graphic.height * bullet_graphic.height) / 2.0;
            }
        );

        var enemy_bullet_graphic = new Image();
        var enemy_bullet_graphic_loaded = false;
        enemy_bullet_graphic.src = "graphics/enemy_bullet.svg";
        enemy_bullet_graphic.radius = -1;
        enemy_bullet_graphic.addEventListener(
            "load",
            function () {
                enemy_bullet_graphic_loaded = true;
                enemy_bullet_graphic.radius = Math.sqrt(enemy_bullet_graphic.width * enemy_bullet_graphic.width + enemy_bullet_graphic.height * enemy_bullet_graphic.height) / 2.0;
            }
        );


        function draw_bullet(bullet) {
            var color = "#1ef9de";
            var size = 20.0;

            graphics.save();

            graphics.translate(bullet.x, bullet.y);

            if (bullet_graphic_loaded && bullet.player)
                graphics.drawImage(bullet_graphic, -bullet_graphic.width / 2.0, -bullet_graphic.height / 2.0);
            if (enemy_bullet_graphic_loaded && !bullet.player)
                graphics.drawImage(enemy_bullet_graphic, -bullet_graphic.width / 2.0, -bullet_graphic.height / 2.0);

            graphics.restore();

        }

        var bullets = [];

        // CLICK MARKERS
        var click_markers = [];

        function create_click_marker(x, y, color) {
            var initial_size = 0.0;
            var final_size = 30.0;

            var final_color = { r: 46, b: 46, g: 46 };
            var duration = 200;

            click_markers.push(
                {
                    x: x,
                    y: y,
                    initial_size: initial_size,
                    final_size: final_size,
                    initial_color: color,
                    final_color: final_color,
                    creation_time: (new Date()).getTime(),
                    duration: duration
                });
        }

        function lerp(x, y, t) {
            return x + t * (y - x);
        }

        function draw_click_marker(marker, offset) {
            var color = "#1ef9de";

            var t = ((new Date()).getTime() - marker.creation_time) / marker.duration;

            var color = {
                r: lerp(marker.initial_color.r, marker.final_color.r, t),
                g: lerp(marker.initial_color.g, marker.final_color.g, t),
                b: lerp(marker.initial_color.b, marker.final_color.b, t),
            };

            var size = lerp(marker.initial_size, marker.final_size, t);

            graphics.save();

            graphics.translate(marker.x + offset.x, marker.y + offset.y);

            graphics.lineWidth = 3;
            graphics.strokeStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";

            graphics.beginPath();

            graphics.arc(0, 0, size, 0, 2 * Math.PI);

            graphics.stroke();
            graphics.restore();

        }

        /* PARTICLE SYSTEM */
        var particles = [];

        function create_particles(x, y, color, count, volume) {
            var size = 10;
            var final_color = { r: 46, b: 46, g: 46 };
            var duration = 400;
            var speed_scale = 1;

            for (var i = 0; i < count; i++) {
                particles.push(
                    {
                        x: x + volume * (Math.random() - 0.5),
                        y: y + volume * (Math.random() - 0.5),
                        vx: (Math.random() - 0.5) * speed_scale,
                        vy: (Math.random() - 0.5) * speed_scale,
                        size: size,
                        initial_color: color,
                        final_color: final_color,
                        creation_time: (new Date()).getTime(),
                        duration: duration
                    });
            }
        }

        function update_particles(dt) {
            for (var i = 0; i < particles.length; i++) {
                particles[i].x += particles[i].vx * dt;
                particles[i].y += particles[i].vy * dt;

                if (particles[i].x > game_width)
                    particles[i].x -= game_width;
                if (particles[i].x < 0)
                    particles[i].x += game_width;

                if (particles[i].y > game_height)
                    particles[i].y -= game_height;
                if (particles[i].y < 0)
                    particles[i].y += game_height;

                var t = ((new Date()).getTime() - particles[i].creation_time) / particles[i].duration;

                if (t > 1)
                    particles.splice(i, 1);
            }
        }

        function draw_particles() {
            for (var i = 0; i < particles.length; i++) {
                var t = ((new Date()).getTime() - particles[i].creation_time) / particles[i].duration;

                var color = {
                    r: lerp(particles[i].initial_color.r, particles[i].final_color.r, t),
                    g: lerp(particles[i].initial_color.g, particles[i].final_color.g, t),
                    b: lerp(particles[i].initial_color.b, particles[i].final_color.b, t),
                };

                if (t < 1) {

                    graphics.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";

                    graphics.fillRect(particles[i].x, particles[i].y, particles[i].size, particles[i].size);

                }
            }

        }

        /* SOUND CODE */
        function sound(src) {
            this.sound = document.createElement("audio");
            this.sound.src = src;
            this.sound.setAttribute("preload", "auto");
            this.sound.setAttribute("controls", "none");
            this.sound.style.display = "none";

            document.body.appendChild(this.sound);

            this.play = function () {
                this.sound.play();
            }

            this.stop = function () {
                this.sound.pause();
            }
        }

        var explosion_sounds =
            [
                new sound("sounds/engine_1.wav"),
                new sound("sounds/explosion_1.wav"),
                new sound("sounds/explosion_2.wav"),
                new sound("sounds/explosion_3.wav")
            ];

        function play_explosion() {
            var index = Math.floor(Math.random() * explosion_sounds.length);

            if(sfx_enabled)
                explosion_sounds[index].play();
        }

        function play_ship_fire() {
            var index = Math.floor(Math.random() * ship_fire_sounds.length);

            if(sfx_enabled)
                ship_fire_sounds[index].play();
        }

        var current_song = -1;

        var music_enabled = true;
        var sfx_enabled = true;

        var background_music = [
            new sound("music/song_1.wav"),
            new sound("music/song_2.wav"),
            new sound("music/song_3.wav")
        ];

        for (var i = 0; i < background_music.length; i++) {
            background_music[i].sound.volume = 0.15;
            background_music[i].sound.loop = true;
        }

        function stop_song() {
            if (current_song > -1)
                background_music[current_song].stop();
        }

        function play_song() {
            if (current_song > -1)
                background_music[current_song].stop();

            var index = Math.floor(Math.random() * background_music.length);
            while (current_song == index)
                index = Math.floor(Math.random() * background_music.length);

            if(music_enabled)
                background_music[index].play();
            current_song = index;
        }

        /* INITIALIZATION CODE */
        function initialize_start_screen() {
            if (!(ship_graphic_loaded && enemy_graphic_loaded && bullet_graphic_loaded)) {
                requestAnimFrame(initialize_start_screen);
                return;
            }

            game_score = 0;

            ships = [];
            asteroids = [];
            selected_ships = [];
            bullets = [];
            enemy_ships = [];

            for (var i = 0; i < 6; i++) {

                var position = {
                    x: game_width * Math.random(),
                    y: game_height * Math.random()
                };

                var base_radius = game_parameters.asteroid_initial_radius;

                if (Math.random() > 0.5)
                    base_radius /= 1.4;

                if (Math.random() > 0.5)
                    base_radius /= 1.4;

                create_asteroid(position, game_parameters.asteroid_initial_radius);
            }

            for (var i = 0; i < 3; i++)
                create_enemy_ship(Math.random() * game_width, Math.random() * game_height);

            play_song();

            game_loop();
        }

        function initialize_game_data() {
            if (!ship_graphic_loaded) {
                requestAnimFrame(initialize_game_data);
                return;
            }

            asteroids = [];
            selected_ships = [];
            bullets = [];
            enemy_ships = [];

            if (game_level == 1) {
                ships = [];

                for (var i = 0; i < 5; i++) {
                    ships.push(
                        {
                            x: game_width / 2.0 + 200 * Math.random() - 100.0,
                            y: game_height / 2.0 + 200 * Math.random() - 100.0,
                            angle: 0.0,
                            target: { x: 0, y: 0, active: false, command_id: 0 },
                            last_fired: (new Date()).getTime(),
                            max_radius: ship_graphic.radius
                        });
                }
            } else {
                for (var i = 0; i < ships.length; i++) {
                    ships[i].x = game_width / 2.0 + 200 * Math.random() - 100.0;
                    ships[i].y = game_height / 2.0 + 200 * Math.random() - 100.0;
                }

                ships.push(
                    {
                        x: game_width / 2.0 + 200 * Math.random() - 100.0,
                        y: game_height / 2.0 + 200 * Math.random() - 100.0,
                        angle: 0.0,
                        target: { x: 0, y: 0, active: false, command_id: 0 },
                        last_fired: (new Date()).getTime(),
                        max_radius: ship_graphic.radius
                    });
            }

            var asteroids_per_level = [1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 9, 10];
            var enemies_per_level = [0, 1, 0, 1, 0, 1, 2, 0, 1, 2, 2, 0, 1, 2, 0, 1, 2, 0, 1]

            for (var i = 0; i < asteroids_per_level[game_level - 1]; i++) {

                var position = {
                    x: game_width * Math.random(),
                    y: game_height * Math.random()
                };

                while (Math.abs(position.x - game_width / 2.0) < 200.0)
                    position.x = game_width * Math.random();

                while (Math.abs(position.y - game_height / 2.0) < 200.0)
                    position.y = game_height * Math.random();

                create_asteroid(position, game_parameters.asteroid_initial_radius);
            }

            for (var i = 0; i < enemies_per_level[game_level - 1]; i++) {
                var position = {
                    x: game_width * Math.random(),
                    y: game_height * Math.random()
                };

                while (Math.abs(position.x - game_width / 2.0) < 200.0)
                    position.x = game_width * Math.random();

                while (Math.abs(position.y - game_height / 2.0) < 200.0)
                    position.y = game_height * Math.random();

                create_enemy_ship(position.x, position.y);
            }

            play_song();

        }

        /* HIGH SCORE CODE */
        var high_score_list = [];

        function load_high_scores() {
            high_score_list = [];

            scores = localStorage.getItem("scores");

            if (!scores)
                return;

            scores = scores.split("|");

            for (var j = 0; j < scores.length - 1; j++) {
                high_score_list.push({
                    name: scores[j].split("][")[0],
                    score: Number(scores[j].split("][")[1])
                });
            }
        }

        function save_high_scores() {
            var date = new Date();

            // NOTE(schsam): We only save high scores locally for 5 months.
            date.setMonth(date.getMonth() + 5);

            var score_string = "";

            for (var i = 0; i < high_score_list.length; i++) {
                score_string += high_score_list[i].name + "][" + high_score_list[i].score + "|"
            }

            localStorage.setItem("scores", score_string);
        }

        function create_dummy_scores() {
            load_high_scores();

            if (high_score_list.length == 0) {
                high_score_list.push({ name: "Can", score: 5000 });
                high_score_list.push({ name: "You", score: 3000 });
                high_score_list.push({ name: "Beat", score: 2000 });
                high_score_list.push({ name: "These", score: 1000 });
                high_score_list.push({ name: "Scores", score: 700 });
                high_score_list.push({ name: "I", score: 400 });
                high_score_list.push({ name: "Could", score: 300 });
                high_score_list.push({ name: "Not", score: 200 });
                high_score_list.push({ name: "GL", score: 100 });
                high_score_list.push({ name: "GL", score: 100 });
            }

            save_high_scores();
        }

        function update_high_score_list() {
            var html_code = "<h2>High Scores</h2><br />";

            html_code += "<div class=\"row\">";
            html_code += "<div class=\"column\">";
            for (var i = 0; i < high_score_list.length; i++) {
                html_code += "<p><span style=\"color: yellowgreen\">" + high_score_list[i].name + "</span></p><br />";
            }
            html_code += "</div>";
            html_code += "<div class=\"column\">";
            for (var i = 0; i < high_score_list.length; i++) {
                html_code += "<p><span style=\"color: cornflowerblue\">" + high_score_list[i].score + "</span></p><br />";
            }
            html_code += "</div>";
            html_code += "</div>";

            $("#high-score-screen")[0].innerHTML = html_code;
        }

        create_dummy_scores();
        update_high_score_list();

        /* RENDER / UPDATE CODE */
        function draw_game() {
            graphics.setTransform(1, 0, 0, 1, 0, 0);

            graphics.fillStyle = game_parameters.background_color;

            graphics.fillRect(0, 0, game_width, game_height);

            draw_particles();

            for (var i = 0; i < ships.length; i++) {
                draw_periodic(ships[i], draw_ship);
            }

            for (var i = 0; i < enemy_ships.length; i++) {
                draw_periodic(enemy_ships[i], draw_enemy);
            }

            for (var i = 0; i < selected_ships.length; i++) {
                var id = selected_ships[i].id;

                draw_ship_selector(ships[id], selected_ships[i]);
            }

            for (var i = 0; i < asteroids.length; i++) {
                draw_periodic(asteroids[i], draw_asteroid);
            }

            for (var i = 0; i < bullets.length; i++) {
                draw_bullet(bullets[i]);
            }

            for (var i = 0; i < click_markers.length; i++) {
                draw_periodic(click_markers[i], draw_click_marker);

                if ((new Date()).getTime() - click_markers[i].creation_time > click_markers[i].duration) {
                    click_markers.splice(i, 1);
                }
            }

            if (mouse.is_locked)
                draw_mouse();
        }

        var game_parameters = {
            background_color: "#2e2e2e",
            ship_fire_rate: 200,
            ship_speed: 0.3,
            min_ship_to_target: 5.0,
            ship_attack_range: 400,
            bullet_speed: 0.5,
            asteroid_initial_radius: 150.0,
            asteroid_velocity_scale: 0.2 * 150.0,
            asteroid_omega_scale: 0.005
        };

        function update_game(dt) {
            // SHIP TO TARGET LOGIC
            for (var i = 0; i < ships.length; i++) {
                if (ships[i].target.active && ships[i].target.mode == "move")
                    ships[i] = move(ships[i]);

                if (ships[i].target.active && ships[i].target.mode == "attack") {
                    var target = null;


                    if (ships[i].target.asteroid != null)
                        target = asteroids[ships[i].target.asteroid];

                    if (ships[i].target.enemy != null)
                        target = enemy_ships[ships[i].target.enemy];

                    if (target)
                        ships[i] = attack(ships[i], target);
                }

                if (ships[i].target.active && ships[i].target.mode == "attack-move") {

                    target = null;

                    for (var j = 0; j < asteroids.length; j++) {
                        var dx = ships[i].x - asteroids[j].x;
                        var dy = ships[i].y - asteroids[j].y;

                        if (Math.abs(dx) > game_width / 2.0)
                            dx -= Math.sign(dx) * game_width;
                        if (Math.abs(dy) > game_height / 2.0)
                            dy -= Math.sign(dy) * game_height;

                        var norm = Math.sqrt(dx * dx + dy * dy);

                        if (norm < game_parameters.ship_attack_range) {
                            target = asteroids[j];
                        }
                    }

                    for (var j = 0; j < enemy_ships.length; j++) {
                        var dx = ships[i].x - enemy_ships[j].x;
                        var dy = ships[i].y - enemy_ships[j].y;

                        if (Math.abs(dx) > game_width / 2.0)
                            dx -= Math.sign(dx) * game_width;
                        if (Math.abs(dy) > game_height / 2.0)
                            dy -= Math.sign(dy) * game_height;

                        var norm = Math.sqrt(dx * dx + dy * dy);

                        if (norm < game_parameters.ship_attack_range) {
                            target = enemy_ships[j];
                        }
                    }

                    if (target) {
                        ships[i] = attack(ships[i], target);
                    } else {
                        ships[i] = move(ships[i]);
                    }

                }

            }

            // SHIP SHIP OVERLAP
            var ship_repulsion_scale = 1.0;
            var goal_separation_radius = ship_graphic.radius * 3;

            for (var i = 0; i < ships.length; i++) {
                for (var j = i + 1; j < ships.length; j++) {
                    var dx = ships[i].x - ships[j].x;
                    var dy = ships[i].y - ships[j].y;

                    var norm = Math.sqrt(dx * dx + dy * dy);

                    if (norm < goal_separation_radius) {
                        ships[i].x += (1.0 - norm / goal_separation_radius) * dx / norm * dt * ship_repulsion_scale;
                        ships[i].y += (1.0 - norm / goal_separation_radius) * dx / norm * dt * ship_repulsion_scale;
                        ships[j].x -= (1.0 - norm / goal_separation_radius) * dx / norm * dt * ship_repulsion_scale;
                        ships[j].y -= (1.0 - norm / goal_separation_radius) * dy / norm * dt * ship_repulsion_scale;

                        if ((ships[i].target.mode == "move" || ships[i].target.mode == "attack-move") &&
                            ships[i].target.command_id == ships[j].target.command_id) {
                            ships[i].target.active = ships[i].target.active && ships[j].target.active;
                            ships[j].target.active = ships[i].target.active && ships[j].target.active;
                        }
                    }
                }
            }

            // SHIP ASTEROID OVERLAP
            for (var i = 0; i < ships.length; i++) {
                for (var j = 0; j < asteroids.length; j++) {
                    if (ship_asteroid_intersection(ships[i], asteroids[j])) {

                        var selected_index = -1;

                        for (var k = 0; k < selected_ships.length; k++) {
                            if (selected_ships[k].id == i)
                                selected_index = k;
                            if (selected_ships[k].id > i)
                                selected_ships[k].id--;
                        }

                        if (selected_index >= 0)
                            selected_ships.splice(selected_index, 1);

                        for (var k = 0; k < enemy_ships.length; k++) {

                            if (enemy_ships[k].target != null && enemy_ships[k].target_type == "ship" && enemy_ships[k].target == i)
                                enemy_ships[k].target = null;
                            else if (enemy_ships[k].target != null && enemy_ships[k].target_type == "ship" && enemy_ships[k].target > i)
                                enemy_ships[k].target--;

                        }

                        play_explosion();
                        create_particles(ships[i].x, ships[i].y, { r: 0, g: 255, b: 0 }, 25, ship_graphic.radius / 2.0);

                        ships.splice(i, 1);

                        break;
                    }
                }
            }

            // ENEMY ASTEROID OVERLAP
            for (var i = 0; i < enemy_ships.length; i++) {
                for (var j = 0; j < asteroids.length; j++) {
                    if (ship_asteroid_intersection(enemy_ships[i], asteroids[j])) {

                        play_explosion();
                        create_particles(enemy_ships[i].x, enemy_ships[i].y, { r: 255, g: 0, b: 0 }, 25, enemy_graphic.radius / 2.0);

                        for (var z = 0; z < ships.length; z++) {
                            if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.enemy == j)
                                ships[z].target.active = false;
                            if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.enemy > j)
                                ships[z].target.asteroid--;

                        }

                        enemy_ships.splice(i, 1);

                        break;
                    }
                }
            }

            // ASTEROID DYNAMICS
            for (var i = 0; i < asteroids.length; i++) {
                asteroids[i].x += dt * asteroids[i].vx;
                asteroids[i].y += dt * asteroids[i].vy;

                if (asteroids[i].x > game_width)
                    asteroids[i].x -= game_width;
                if (asteroids[i].y > game_height)
                    asteroids[i].y -= game_height;
                if (asteroids[i].x < 0)
                    asteroids[i].x += game_width;
                if (asteroids[i].y < 0)
                    asteroids[i].y += game_height;

                asteroids[i].angle += dt * asteroids[i].omega;
            }

            // BULLET DYNAMICS
            var bullet_damage = 1;
            var minimum_asteroid_radius = 80;
            var bullet_duration = 3000;

            for (var i = 0; i < bullets.length; i++) {
                bullets[i].x += bullets[i].vx * dt;
                bullets[i].y += bullets[i].vy * dt;

                if (bullets[i].x > game_width)
                    bullets[i].x -= game_width;
                if (bullets[i].y > game_height)
                    bullets[i].y -= game_height;
                if (bullets[i].x < 0)
                    bullets[i].x += game_width;
                if (bullets[i].y < 0)
                    bullets[i].y += game_height;

                if ((new Date()).getTime() - bullets[i].fire_time > bullet_duration) {
                    bullets.splice(i, 1);
                    continue;
                }

                var bullet_collided = false;

                for (var j = 0; j < asteroids.length; j++) {
                    if (point_in_asteroid(bullets[i].x, bullets[i].y, asteroids[j])) {
                        bullets.splice(i, 1);

                        asteroids[j].health -= bullet_damage;

                        if (asteroids[j].health < 0) {
                            play_explosion();

                            for (var z = 0; z < ships.length; z++) {
                                if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.asteroid == j)
                                    ships[z].target.active = false;
                                if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.asteroid > j)
                                    ships[z].target.asteroid--;

                            }

                            for (var k = 0; k < enemy_ships.length; k++) {
                                if (enemy_ships[k].target && enemy_ships[k].target_type == "asteroid" && enemy_ships[k].target == j)
                                    enemy_ships[k].target = null;
                                if (enemy_ships[k].target && enemy_ships[k].target_type == "asteroid" && enemy_ships[k].target > j)
                                    enemy_ships[k].target--;

                            }

                            var asteroid_radius = asteroids[j].size;
                            var pos = { x: asteroids[j].x, y: asteroids[j].y };
                            asteroids.splice(j, 1);

                            if (asteroid_radius > minimum_asteroid_radius) {
                                for (var k = 0; k < 3; k++) {
                                    create_asteroid(pos, asteroid_radius / 1.4);
                                }
                            }

                            create_particles(pos.x, pos.y, { r: 255, g: 255, b: 255 }, 35, asteroid_radius / 2.0);
                            game_score += Math.floor(asteroid_radius);

                            document.getElementById("score").innerHTML = "<h1>" + game_score + "</h1>";
                        }

                        bullet_collided = true;
                        break;
                    }
                }

                if (!bullet_collided) {
                    for (var j = 0; j < enemy_ships.length; j++) {
                        if (bullets[i].player && point_in_enemy(bullets[i].x, bullets[i].y, enemy_ships[j])) {
                            bullets.splice(i, 1);

                            play_explosion();
                            create_particles(enemy_ships[j].x, enemy_ships[j].y, { r: 255, g: 0, b: 0 }, 35, enemy_ships[j].max_radius);

                            for (var z = 0; z < ships.length; z++) {
                                if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.enemy == j)
                                    ships[z].target.active = false;
                                if (ships[z].target.active && ships[z].target.mode == "attack" && ships[z].target.enemy > j)
                                    ships[z].target.enemy--;
                            }

                            enemy_ships.splice(j, 1);

                            game_score += 1000;

                            document.getElementById("score").innerHTML = "<h1>" + game_score + "</h1>";

                            bullet_collided = true;
                            break;
                        }
                    }
                }

                if (!bullet_collided) {
                    for (var j = 0; j < ships.length; j++) {
                        if (!(bullets[i].player) && point_in_enemy(bullets[i].x, bullets[i].y, ships[j])) {
                            bullets.splice(i, 1);

                            play_explosion();
                            create_particles(ships[j].x, ships[j].y, { r: 0, g: 255, b: 0 }, 35, ships[j].max_radius);

                            var selected_index = -1;

                            for (var k = 0; k < selected_ships.length; k++) {
                                if (selected_ships[k].id == j)
                                    selected_index = k;
                                if (selected_ships[k].id > j)
                                    selected_ships[k].id--;
                            }

                            if (selected_index >= 0)
                                selected_ships.splice(selected_index, 1);

                            for (var z = 0; z < enemy_ships.length; z++) {
                                if (enemy_ships[z].target != null && enemy_ships[z].target_type == "ship" && enemy_ships[z].target == j)
                                    enemy_ships[z].target = null;
                                else if (enemy_ships[z].target != null && enemy_ships[z].target_type == "ship" && enemy_ships[z].target > j)
                                    enemy_ships[z].target--;
                            }

                            ships.splice(j, 1);

                            break;
                        }
                    }
                }
            }

            update_enemy_ships(dt);

            update_particles(dt);

            if (ships.length == 0 && game_state == "play") {
                $("#death-screen")[0].style.display = "block";
                var death_string = $("#death-screen")[0].innerHTML;
                death_string = death_string.replace("{points}", game_score);
                death_string = death_string.replace("{level}", game_level);

                $("#death-screen")[0].innerHTML = death_string;

                $("#high-score-option")[0].style.display = "none";
                $("#no-high-score-option")[0].style.display = "block";

                for (var i = 0; i < high_score_list.length; i++) {
                    if (game_score > high_score_list[i].score) {
                        $("#high-score-option")[0].style.display = "block";
                        $("#no-high-score-option")[0].style.display = "none";
                        break;
                    }
                }

                $("#high-score-screen")[0].style.display = "block";

                game_state = "dead";
                document.exit_pointer_lock();
            }

            if (asteroids.length == 0 && game_state == "play") {
                game_level++;
                document.getElementById("level").innerHTML = "<h1>Level: " + game_level + "</h1>";

                initialize_game_data();
            }
        }

        var command_count = 0;
        var selected_ships = [];

        function handle_input() {
            var ship_select_radius = Math.sqrt(ship_graphic.width * ship_graphic.width + ship_graphic.height * ship_graphic.height) / 2.0;

            if (mouse.is_clicked == 0 && mouse.mode == "select") {

                if (!(16 in keyboard)) {
                    selected_ships = [];
                }

                for (var i = 0; i < ships.length; i++) {
                    var dx = ships[i].x - mouse.x;
                    var dy = ships[i].y - mouse.y;

                    if (dx * dx + dy * dy < ship_select_radius * ship_select_radius)
                        selected_ships.push({ id: i });
                }
            }

            if (mouse.is_clicked == 0 && mouse.mode == "attack") {

                var selected_asteroid = -1;

                for (var i = 0; i < asteroids.length; i++) {
                    if (point_in_asteroid(mouse.x, mouse.y, asteroids[i]))
                        selected_asteroid = i;
                }

                var selected_enemy = -1;

                for (var i = 0; i < enemy_ships.length; i++) {
                    if (point_in_enemy(mouse.x, mouse.y, enemy_ships[i]))
                        elected_enemy = i;
                }

                for (var i = 0; i < selected_ships.length; i++) {
                    if (selected_asteroid < 0) {
                        ships[selected_ships[i].id].target = {
                            x: mouse.x, y: mouse.y,
                            active: true, command_id: command_count,
                            mode: "attack-move"
                        };
                    } else if (selected_asteroid > 0) {
                        ships[selected_ships[i].id].target = {
                            asteroid: selected_asteroid,
                            enemy: null,
                            active: true, command_id: command_count,
                            mode: "attack"
                        };
                    } else if (selected_enemy > 0) {
                        ships[selected_ships[i].id].target = {
                            asteroid: null,
                            enemy: selected_enemy,
                            active: true, command_id: command_count,
                            mode: "attack"
                        };
                    }
                }

                if (selected_asteroid < 0)
                    create_click_marker(mouse.x, mouse.y, { r: 255, g: 0, b: 0 });

                command_count++;

                mouse.mode = "select";
            }

            if (mouse.is_down == 0 && mouse.is_dragging) {
                if (!(16 in keyboard)) {
                    selected_ships = [];
                }

                var min_mouse_x = Math.min(mouse.unwrapped_x, mouse.down_x);
                var min_mouse_y = Math.min(mouse.unwrapped_y, mouse.down_y);

                var max_mouse_x = Math.max(mouse.unwrapped_x, mouse.down_x);
                var max_mouse_y = Math.max(mouse.unwrapped_y, mouse.down_y);

                graphics.beginPath();

                graphics.fillStyle = "#0000FF"
                graphics.globalAlpha = 0.2;

                for (var tx = -1; tx <= 1; tx++) {
                    for (var ty = -1; ty <= 1; ty++) {
                        var offset = { x: 0, y: 0 };
                        var draw = false;

                        if (tx == 0 && ty == 0)
                            draw = true;

                        if (tx < 0 && min_mouse_x < 0) {
                            offset.x = game_width;
                            draw = true;
                        }

                        if (ty < 0 && min_mouse_y < 0) {
                            offset.y = game_height;
                            draw = true;
                        }

                        if (tx > 0 && max_mouse_x > game_width) {
                            offset.x = -game_width;
                            draw = true;
                        }

                        if (ty > 0 && min_mouse_y > game_height) {
                            offset.y = -game_height;
                            draw = true;
                        }

                        if (draw) {
                            for (var i = 0; i < ships.length; i++) {
                                if (ships[i].x > min_mouse_x + offset.x && ships[i].x < max_mouse_x + offset.x &&
                                    ships[i].y > min_mouse_y + offset.y && ships[i].y < max_mouse_y + offset.y)
                                    selected_ships.push({ id: i });
                            }

                            graphics.fillRect(
                                min_mouse_x + offset.x,
                                min_mouse_y + offset.y,
                                max_mouse_x - min_mouse_x,
                                max_mouse_y - min_mouse_y);
                        }
                    }
                }


                graphics.globalAlpha = 1.0
            }

            if (mouse.is_clicked == 2 && selected_ships.length > 0 && mouse.mode == "select") {

                var selected_asteroid = -1;

                for (var i = 0; i < asteroids.length; i++) {
                    if (point_in_asteroid(mouse.x, mouse.y, asteroids[i]))
                        selected_asteroid = i;
                }

                var selected_enemy = -1;

                for (var i = 0; i < enemy_ships.length; i++) {
                    if (point_in_enemy(mouse.x, mouse.y, enemy_ships[i]))
                        selected_enemy = i;
                }

                for (var i = 0; i < selected_ships.length; i++) {
                    if (selected_asteroid < 0 && selected_enemy < 0) {
                        ships[selected_ships[i].id].target = {
                            x: mouse.x, y: mouse.y,
                            active: true, command_id: command_count,
                            mode: "move"
                        };

                    } else if (selected_asteroid >= 0) {
                        ships[selected_ships[i].id].target = {
                            asteroid: selected_asteroid,
                            enemy: null,
                            active: true, command_id: command_count,
                            mode: "attack"
                        };
                    } else if (selected_enemy >= 0) {
                        ships[selected_ships[i].id].target = {
                            asteroid: null,
                            enemy: selected_enemy,
                            active: true, command_id: command_count,
                            mode: "attack"
                        };
                    }
                }

                if (selected_asteroid < 0 && selected_enemy < 0)
                    create_click_marker(mouse.x, mouse.y, { r: 0, g: 255, b: 0 });

                command_count++;
            }

            if (mouse.is_clicked == 2 && mouse.mode == "attack") {
                mouse.mode = "select";
            }


            mouse.is_clicked = -1;
        }

        initialize_start_screen();
    </script>
</body>
